<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prince of Persia</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: #000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100vh;
    overflow: hidden;
    font-family: 'Press Start 2P', monospace;
    cursor: none;
  }

  #gameContainer {
    position: relative;
    border: 3px solid #3a2a1a;
    box-shadow: 0 0 40px rgba(180, 120, 60, 0.15), inset 0 0 60px rgba(0,0,0,0.5);
  }

  canvas {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
  }

  #overlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.85);
    z-index: 10;
    transition: opacity 0.5s;
  }

  #overlay.hidden {
    opacity: 0;
    pointer-events: none;
  }

  #overlay h1 {
    color: #d4a44a;
    font-size: 28px;
    text-shadow: 2px 2px 0 #8b4513, 0 0 20px rgba(212,164,74,0.5);
    margin-bottom: 8px;
    letter-spacing: 4px;
  }

  #overlay .subtitle {
    color: #a07030;
    font-size: 10px;
    margin-bottom: 40px;
    letter-spacing: 2px;
  }

  #overlay .controls {
    color: #887766;
    font-size: 8px;
    line-height: 2.2;
    text-align: left;
    margin-bottom: 30px;
  }

  #overlay .controls span {
    color: #d4a44a;
  }

  #overlay .start-msg {
    color: #d4a44a;
    font-size: 10px;
    animation: blink 1.2s infinite;
  }

  @keyframes blink {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.2; }
  }

  #hud {
    position: absolute;
    top: 0; left: 0; right: 0;
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    z-index: 5;
    pointer-events: none;
  }

  .health-bar {
    display: flex;
    gap: 3px;
  }

  .health-pip {
    width: 16px;
    height: 8px;
    border: 1px solid #8b4513;
    transition: background 0.3s;
  }

  .health-pip.full { background: #cc3333; box-shadow: 0 0 4px rgba(204,51,51,0.5); }
  .health-pip.empty { background: #2a1a1a; }

  #levelDisplay, #timerDisplay {
    color: #d4a44a;
    font-size: 8px;
    letter-spacing: 1px;
  }

  #deathOverlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(80, 0, 0, 0.8);
    z-index: 15;
  }

  #deathOverlay.show { display: flex; }

  #deathOverlay h2 {
    color: #cc3333;
    font-size: 18px;
    margin-bottom: 20px;
    text-shadow: 0 0 10px rgba(204,51,51,0.5);
  }

  #deathOverlay .restart-msg {
    color: #aa6666;
    font-size: 9px;
    animation: blink 1.2s infinite;
  }

  #winOverlay {
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.85);
    z-index: 15;
  }

  #winOverlay.show { display: flex; }

  #winOverlay h2 {
    color: #d4a44a;
    font-size: 16px;
    margin-bottom: 10px;
    text-shadow: 0 0 15px rgba(212,164,74,0.6);
  }

  #winOverlay p {
    color: #a07030;
    font-size: 9px;
    margin-bottom: 20px;
  }

  #winOverlay .restart-msg {
    color: #d4a44a;
    font-size: 9px;
    animation: blink 1.2s infinite;
  }
</style>
</head>
<body>

<div id="gameContainer">
  <canvas id="game" width="768" height="480"></canvas>

  <div id="hud">
    <div>
      <div class="health-bar" id="playerHealth"></div>
    </div>
    <div id="levelDisplay">LEVEL 1</div>
    <div id="timerDisplay">60:00</div>
    <div>
      <div class="health-bar" id="enemyHealth"></div>
    </div>
  </div>

  <div id="overlay">
    <h1>PRINCE OF PERSIA</h1>
    <div class="subtitle">THE SANDS OF TIME</div>
    <div class="controls">
      <span>ARROWS</span> .... MOVE &amp; CLIMB<br>
      <span>UP</span> ......... JUMP<br>
      <span>SHIFT</span> ...... CAREFUL STEP<br>
      <span>SPACE</span> ...... ATTACK / PICK UP SWORD<br>
      <span>DOWN</span> ....... CROUCH / DROP DOWN
    </div>
    <div class="start-msg">PRESS ENTER TO BEGIN</div>
  </div>

  <div id="deathOverlay">
    <h2>YOU HAVE PERISHED</h2>
    <div class="restart-msg">PRESS ENTER TO RETRY</div>
  </div>

  <div id="winOverlay">
    <h2>LEVEL COMPLETE</h2>
    <p>The Prince advances deeper into the dungeon...</p>
    <div class="restart-msg">PRESS ENTER TO CONTINUE</div>
  </div>
</div>

<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width;
const H = canvas.height;

// ---- CONSTANTS ----
const TILE = 48;
const COLS = Math.ceil(W / TILE); // 16
const ROWS = Math.ceil(H / TILE); // 10
const GRAVITY = 0.55;
const MAX_FALL = 12;
const PLAYER_SPEED = 2.8;
const JUMP_FORCE = -9.5;
const ATTACK_RANGE = 50;
const ATTACK_DAMAGE = 1;

// ---- COLORS ----
const C = {
  bg: '#0a0806',
  wall: '#3a2a1a',
  wallLight: '#4a3828',
  wallDark: '#2a1a10',
  floor: '#5a4a3a',
  floorTop: '#6a5a48',
  brick: '#4d3b2a',
  brickLine: '#2a1a10',
  spike: '#888',
  spikeDark: '#555',
  gate: '#8a7a6a',
  gateBar: '#6a5a4a',
  torch: '#ff9933',
  torchGlow: 'rgba(255,153,51,0.08)',
  potion: '#cc3333',
  potionGlow: 'rgba(204,51,51,0.3)',
  sword: '#cccccc',
  swordGlow: 'rgba(200,200,200,0.3)',
  exit: '#d4a44a',
  exitGlow: 'rgba(212,164,74,0.15)',
  player: '#dddddd',
  playerOutline: '#aa8866',
  enemy: '#882222',
  enemyOutline: '#662222',
  loose: '#4d3b2a',
};

// ---- TILE TYPES ----
const T = {
  EMPTY: 0,
  WALL: 1,
  FLOOR: 2,
  SPIKES: 3,
  GATE_CLOSED: 4,
  GATE_OPEN: 5,
  TORCH: 6,
  POTION: 7,
  SWORD_PICKUP: 8,
  EXIT: 9,
  LOOSE_FLOOR: 10,
  PRESSURE_PLATE: 11,
  PILLAR: 12,
  CHOMPER: 13,
};

// ---- GAME STATE ----
let gameState = 'menu'; // menu, playing, dead, win
let currentLevel = 0;
let gameTime = 3600; // 60 minutes in seconds
let frameCount = 0;
let screenShake = 0;
let particles = [];
let torchFlicker = 0;

// ---- LEVELS ----
const levels = [
  // Level 1 - Introduction
  {
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,2,2,2,2,6,2,2,2,2,2,0,0,6,2,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,7,0,0,0,0,9,1],
      [1,2,2,2,11,2,2,2,2,2,2,10,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 80, y: 350 },
    enemies: [
      { x: 500, y: 350, health: 2, hasSword: true, patrol: true, patrolRange: 80 }
    ],
    gates: [
      { gx: -1, gy: -1, plateX: 4, plateY: 8 }
    ],
    swordPickup: null,
  },
  // Level 2 - Spikes & Combat
  {
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,2,6,2,2,2,2,2,0,0,2,2,6,2,2,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,7,0,0,0,0,0,0,9,1],
      [1,2,2,2,3,3,2,2,2,2,13,2,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 80, y: 350 },
    enemies: [
      { x: 350, y: 158, health: 2, hasSword: true, patrol: true, patrolRange: 60 },
      { x: 550, y: 350, health: 3, hasSword: true, patrol: true, patrolRange: 70 }
    ],
    gates: [],
    swordPickup: null,
  },
  // Level 3 - The Gauntlet
  {
    map: [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,9,1],
      [1,0,0,0,0,0,2,2,6,2,2,10,2,2,2,1],
      [1,2,6,2,2,2,1,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,1,0,0,0,0,0,0,0,0,1],
      [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,0,0,7,0,0,0,0,0,0,0,0,0,0,0,1],
      [1,2,2,2,2,13,2,2,3,3,2,2,6,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
    ],
    playerStart: { x: 80, y: 350 },
    enemies: [
      { x: 300, y: 158, health: 3, hasSword: true, patrol: true, patrolRange: 50 },
      { x: 580, y: 350, health: 3, hasSword: true, patrol: true, patrolRange: 80 },
    ],
    gates: [],
    swordPickup: null,
  }
];

// ---- PLAYER ----
let player = {
  x: 80, y: 350,
  vx: 0, vy: 0,
  w: 20, h: 40,
  health: 3, maxHealth: 3,
  hasSword: true,
  facing: 1, // 1 right, -1 left
  grounded: false,
  state: 'idle', // idle, run, jump, fall, attack, crouch, careful, dead, climb
  attackTimer: 0,
  attackCooldown: 0,
  hurtTimer: 0,
  animFrame: 0,
  animTimer: 0,
  crouching: false,
  careful: false,
};

// ---- ENEMIES ----
let enemies = [];

// ---- INPUT ----
const keys = {};
const keyDown = {};
window.addEventListener('keydown', e => {
  if (!keys[e.code]) keyDown[e.code] = true;
  keys[e.code] = true;
  e.preventDefault();
});
window.addEventListener('keyup', e => {
  keys[e.code] = false;
  e.preventDefault();
});

function consumeKey(code) {
  if (keyDown[code]) { keyDown[code] = false; return true; }
  return false;
}

// ---- LEVEL LOADING ----
let map = [];
let looseFloors = [];
let chompers = [];
let potions = [];
let swordPickups = [];
let pressurePlates = [];
let gateLinks = [];
let exitPos = null;

function loadLevel(idx) {
  if (idx >= levels.length) {
    idx = 0; // loop
    currentLevel = 0;
  }
  const lv = levels[idx];
  map = lv.map.map(r => [...r]);
  looseFloors = [];
  chompers = [];
  potions = [];
  swordPickups = [];
  pressurePlates = [];
  gateLinks = lv.gates ? [...lv.gates] : [];
  exitPos = null;

  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const t = map[r][c];
      if (t === T.LOOSE_FLOOR) looseFloors.push({ x: c, y: r, falling: false, vy: 0, offset: 0, timer: 0, fallen: false });
      if (t === T.CHOMPER) chompers.push({ x: c, y: r, timer: 0, open: true, phase: Math.random() * Math.PI * 2 });
      if (t === T.POTION) potions.push({ x: c, y: r, collected: false });
      if (t === T.SWORD_PICKUP) swordPickups.push({ x: c, y: r, collected: false });
      if (t === T.PRESSURE_PLATE) pressurePlates.push({ x: c, y: r, activated: false });
      if (t === T.EXIT) exitPos = { x: c * TILE + TILE/2, y: r * TILE + TILE/2 };
    }
  }

  // Reset player
  player.x = lv.playerStart.x;
  player.y = lv.playerStart.y;
  player.vx = 0;
  player.vy = 0;
  player.health = player.maxHealth;
  player.state = 'idle';
  player.attackTimer = 0;
  player.hurtTimer = 0;
  player.facing = 1;
  player.crouching = false;
  player.grounded = false;

  // Load enemies
  enemies = lv.enemies.map(e => ({
    ...e,
    vx: 0, vy: 0,
    w: 20, h: 40,
    facing: -1,
    state: 'idle',
    attackTimer: 0,
    attackCooldown: 0,
    hurtTimer: 0,
    animFrame: 0,
    animTimer: 0,
    grounded: false,
    startX: e.x,
    dead: false,
    alertRange: 180,
    blockChance: 0.3,
    blockTimer: 0,
  }));

  particles = [];
  screenShake = 0;
  updateHUD();
}

// ---- TILE COLLISION ----
function isSolid(c, r) {
  if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return true;
  const t = map[r][c];
  return t === T.WALL || t === T.FLOOR || t === T.TORCH || t === T.PRESSURE_PLATE ||
         t === T.GATE_CLOSED || t === T.LOOSE_FLOOR || t === T.PILLAR || t === T.CHOMPER;
}

function isFloor(c, r) {
  if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return false;
  const t = map[r][c];
  return t === T.FLOOR || t === T.TORCH || t === T.PRESSURE_PLATE ||
         t === T.LOOSE_FLOOR || t === T.CHOMPER;
}

function getTile(px, py) {
  const c = Math.floor(px / TILE);
  const r = Math.floor(py / TILE);
  if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return T.WALL;
  return map[r][c];
}

// ---- ENTITY PHYSICS ----
function moveEntity(ent) {
  // Apply gravity
  ent.vy += GRAVITY;
  if (ent.vy > MAX_FALL) ent.vy = MAX_FALL;

  // Horizontal movement
  let nx = ent.x + ent.vx;
  let ny = ent.y;

  // Horizontal collision
  const halfW = ent.w / 2;
  const headY = ny - ent.h;
  const midY = ny - ent.h / 2;

  // Check left/right
  if (ent.vx < 0) {
    if (isSolid(Math.floor((nx - halfW) / TILE), Math.floor(midY / TILE)) ||
        isSolid(Math.floor((nx - halfW) / TILE), Math.floor((ny - 4) / TILE))) {
      nx = (Math.floor((nx - halfW) / TILE) + 1) * TILE + halfW;
      ent.vx = 0;
    }
  } else if (ent.vx > 0) {
    if (isSolid(Math.floor((nx + halfW) / TILE), Math.floor(midY / TILE)) ||
        isSolid(Math.floor((nx + halfW) / TILE), Math.floor((ny - 4) / TILE))) {
      nx = Math.floor((nx + halfW) / TILE) * TILE - halfW;
      ent.vx = 0;
    }
  }

  ent.x = nx;

  // Vertical movement
  ny = ent.y + ent.vy;

  // Floor collision
  ent.grounded = false;
  if (ent.vy >= 0) {
    const footC = Math.floor(ent.x / TILE);
    const footR = Math.floor(ny / TILE);
    const prevFootR = Math.floor(ent.y / TILE);

    // Check if we crossed a floor boundary
    if (isSolid(footC, footR) && footR > Math.floor((ent.y) / TILE - 0.01)) {
      ny = footR * TILE;
      // Fall damage
      if (ent.vy > 9 && ent === player) {
        ent.health -= 1;
        screenShake = 10;
        spawnParticles(ent.x, ent.y, 8, '#aa6633');
        if (ent.health <= 0) { killPlayer(); return; }
      }
      ent.vy = 0;
      ent.grounded = true;
    }
  }

  // Ceiling collision
  if (ent.vy < 0) {
    const headC = Math.floor(ent.x / TILE);
    const headR = Math.floor((ny - ent.h) / TILE);
    if (isSolid(headC, headR)) {
      ny = (headR + 1) * TILE + ent.h;
      ent.vy = 0;
    }
  }

  ent.y = ny;
}

// ---- PARTICLES ----
function spawnParticles(x, y, count, color) {
  for (let i = 0; i < count; i++) {
    particles.push({
      x, y,
      vx: (Math.random() - 0.5) * 4,
      vy: (Math.random() - 1) * 3,
      life: 20 + Math.random() * 20,
      maxLife: 40,
      color,
      size: 1 + Math.random() * 2,
    });
  }
}

function updateParticles() {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.1;
    p.life--;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

// ---- PLAYER UPDATE ----
function updatePlayer() {
  if (player.state === 'dead') return;

  player.hurtTimer = Math.max(0, player.hurtTimer - 1);
  player.attackCooldown = Math.max(0, player.attackCooldown - 1);
  player.animTimer++;

  if (player.animTimer % 8 === 0) player.animFrame++;

  // Attack
  if (player.attackTimer > 0) {
    player.attackTimer--;
    if (player.attackTimer === 8) { // Hit frame
      for (const e of enemies) {
        if (e.dead) continue;
        const dx = e.x - player.x;
        if (Math.abs(dx) < ATTACK_RANGE && Math.abs(e.y - player.y) < 30) {
          if ((dx > 0 && player.facing === 1) || (dx < 0 && player.facing === -1)) {
            if (e.blockTimer > 0 && Math.random() < e.blockChance) {
              spawnParticles((player.x + e.x) / 2, player.y - 20, 4, '#ffcc66');
            } else {
              e.health -= ATTACK_DAMAGE;
              e.hurtTimer = 15;
              e.vx = player.facing * 3;
              spawnParticles(e.x, e.y - 20, 6, '#cc3333');
              screenShake = 4;
              if (e.health <= 0) {
                e.dead = true;
                e.state = 'dead';
                spawnParticles(e.x, e.y - 20, 12, '#882222');
              }
            }
          }
        }
      }
    }
    player.vx *= 0.5;
    moveEntity(player);
    return;
  }

  // Crouching
  player.crouching = keys['ArrowDown'] && player.grounded;

  // Careful step
  player.careful = keys['ShiftLeft'] || keys['ShiftRight'];

  let speed = player.careful ? PLAYER_SPEED * 0.35 : PLAYER_SPEED;
  if (player.crouching) speed = 0;

  // Horizontal
  if (keys['ArrowLeft'] && !player.crouching) {
    player.vx = -speed;
    player.facing = -1;
  } else if (keys['ArrowRight'] && !player.crouching) {
    player.vx = speed;
    player.facing = 1;
  } else {
    player.vx *= 0.6;
    if (Math.abs(player.vx) < 0.3) player.vx = 0;
  }

  // Jump
  if (consumeKey('ArrowUp') && player.grounded) {
    player.vy = JUMP_FORCE;
    player.grounded = false;
    spawnParticles(player.x, player.y, 4, '#8a7a6a');
  }

  // Attack
  if (consumeKey('Space') && player.hasSword && player.attackCooldown <= 0) {
    player.attackTimer = 16;
    player.attackCooldown = 20;
    player.state = 'attack';
  }

  // State
  if (player.attackTimer <= 0) {
    if (!player.grounded) player.state = player.vy < 0 ? 'jump' : 'fall';
    else if (player.crouching) player.state = 'crouch';
    else if (Math.abs(player.vx) > 0.5) player.state = player.careful ? 'careful' : 'run';
    else player.state = 'idle';
  }

  moveEntity(player);

  // Tile interactions
  const pc = Math.floor(player.x / TILE);
  const pr = Math.floor(player.y / TILE);
  const standR = Math.floor((player.y + 1) / TILE);

  // Spikes
  if (map[standR] && map[standR][pc] === T.SPIKES && player.grounded) {
    player.health = 0;
    killPlayer();
    return;
  }

  // Chompers
  for (const ch of chompers) {
    if (!ch.open && pc === ch.x && standR === ch.y) {
      player.health -= 1;
      player.hurtTimer = 20;
      screenShake = 6;
      spawnParticles(player.x, player.y - 20, 8, '#cc3333');
      if (player.health <= 0) { killPlayer(); return; }
    }
  }

  // Potions
  for (const pot of potions) {
    if (!pot.collected && pc === pot.x && (pr === pot.y || pr === pot.y - 1)) {
      pot.collected = true;
      player.health = Math.min(player.maxHealth, player.health + 1);
      map[pot.y][pot.x] = T.EMPTY;
      spawnParticles(pot.x * TILE + TILE/2, pot.y * TILE + TILE/2, 10, '#cc3333');
      updateHUD();
    }
  }

  // Pressure plates
  for (const pp of pressurePlates) {
    if (!pp.activated && pc === pp.x && standR === pp.y) {
      pp.activated = true;
      // Open linked gates
      for (const gl of gateLinks) {
        if (gl.plateX === pp.x && gl.plateY === pp.y && gl.gx >= 0) {
          map[gl.gy][gl.gx] = T.GATE_OPEN;
        }
      }
      spawnParticles(pp.x * TILE + TILE/2, pp.y * TILE, 6, '#d4a44a');
    }
  }

  // Loose floors
  for (const lf of looseFloors) {
    if (!lf.falling && !lf.fallen && pc === lf.x && standR === lf.y && player.grounded) {
      lf.timer++;
      if (lf.timer > 15) {
        lf.falling = true;
      }
    }
  }

  // Exit
  if (exitPos && Math.abs(player.x - exitPos.x) < 24 && Math.abs(player.y - (exitPos.y + TILE/2)) < 30) {
    winLevel();
  }

  updateHUD();
}

function killPlayer() {
  player.state = 'dead';
  player.vx = 0;
  screenShake = 12;
  spawnParticles(player.x, player.y - 20, 15, '#cc3333');
  setTimeout(() => { gameState = 'dead'; document.getElementById('deathOverlay').classList.add('show'); }, 800);
}

function winLevel() {
  gameState = 'win';
  document.getElementById('winOverlay').classList.add('show');
}

// ---- ENEMY AI ----
function updateEnemies() {
  for (const e of enemies) {
    if (e.dead) continue;

    e.hurtTimer = Math.max(0, e.hurtTimer - 1);
    e.attackCooldown = Math.max(0, e.attackCooldown - 1);
    e.blockTimer = Math.max(0, e.blockTimer - 1);
    e.animTimer = (e.animTimer || 0) + 1;
    if (e.animTimer % 8 === 0) e.animFrame = (e.animFrame || 0) + 1;

    const dx = player.x - e.x;
    const dy = player.y - e.y;
    const dist = Math.abs(dx);

    // Attack timer
    if (e.attackTimer > 0) {
      e.attackTimer--;
      if (e.attackTimer === 8) {
        if (dist < ATTACK_RANGE && Math.abs(dy) < 30) {
          if (player.attackTimer > 4 && Math.random() < 0.3) {
            spawnParticles((player.x + e.x) / 2, player.y - 20, 4, '#ffcc66');
          } else {
            player.health -= ATTACK_DAMAGE;
            player.hurtTimer = 15;
            player.vx = e.facing * 2;
            screenShake = 4;
            spawnParticles(player.x, player.y - 20, 6, '#cc3333');
            if (player.health <= 0) killPlayer();
          }
        }
      }
      e.vx *= 0.5;
      moveEntity(e);
      continue;
    }

    // AI behavior
    if (player.state !== 'dead' && dist < e.alertRange && Math.abs(dy) < 60) {
      // Face player
      e.facing = dx > 0 ? 1 : -1;

      if (dist < ATTACK_RANGE - 10 && e.attackCooldown <= 0) {
        // Attack
        e.attackTimer = 16;
        e.attackCooldown = 30 + Math.random() * 20;
        e.state = 'attack';
      } else if (dist < ATTACK_RANGE + 20) {
        // Block stance
        e.blockTimer = 10;
        e.vx *= 0.5;
        e.state = 'idle';
      } else {
        // Approach
        e.vx = e.facing * PLAYER_SPEED * 0.6;
        e.state = 'run';
      }
    } else if (e.patrol) {
      // Patrol
      const patrolDx = e.x - e.startX;
      if (Math.abs(patrolDx) > e.patrolRange) {
        e.facing = patrolDx > 0 ? -1 : 1;
      }
      e.vx = e.facing * PLAYER_SPEED * 0.3;
      e.state = 'run';
    } else {
      e.vx *= 0.8;
      e.state = 'idle';
    }

    moveEntity(e);
  }
}

// ---- LOOSE FLOORS & CHOMPERS ----
function updateEnvironment() {
  for (const lf of looseFloors) {
    if (lf.falling && !lf.fallen) {
      lf.vy += GRAVITY * 0.5;
      lf.offset += lf.vy;
      if (lf.offset > TILE * 2) {
        lf.fallen = true;
        map[lf.y][lf.x] = T.EMPTY;
        screenShake = 3;
        spawnParticles(lf.x * TILE + TILE/2, (lf.y + 2) * TILE, 8, '#5a4a3a');
      }
    }
  }

  for (const ch of chompers) {
    ch.phase += 0.05;
    ch.open = Math.sin(ch.phase) > 0;
  }

  torchFlicker = Math.sin(frameCount * 0.15) * 0.3 + Math.sin(frameCount * 0.23) * 0.2;
}

// ---- DRAWING ----
function drawTile(c, r, type) {
  const x = c * TILE;
  const y = r * TILE;

  switch(type) {
    case T.WALL:
      ctx.fillStyle = C.wall;
      ctx.fillRect(x, y, TILE, TILE);
      // Brick pattern
      ctx.strokeStyle = C.brickLine;
      ctx.lineWidth = 1;
      for (let by = 0; by < TILE; by += 12) {
        const offset = (Math.floor(by / 12) % 2) * 24;
        for (let bx = offset - 24; bx < TILE; bx += 48) {
          ctx.strokeRect(x + bx + 0.5, y + by + 0.5, 47, 11);
        }
      }
      // Edge highlight
      ctx.fillStyle = C.wallLight;
      ctx.fillRect(x, y, TILE, 2);
      ctx.fillStyle = C.wallDark;
      ctx.fillRect(x, y + TILE - 2, TILE, 2);
      break;

    case T.FLOOR:
    case T.PRESSURE_PLATE:
      // Floor top surface
      ctx.fillStyle = C.floorTop;
      ctx.fillRect(x, y, TILE, 4);
      ctx.fillStyle = C.floor;
      ctx.fillRect(x, y + 4, TILE, TILE - 4);
      // Brick texture on floor face
      ctx.strokeStyle = C.brickLine;
      ctx.lineWidth = 0.5;
      for (let by = 8; by < TILE; by += 12) {
        const offset = (Math.floor(by / 12) % 2) * 20;
        for (let bx = offset - 20; bx < TILE; bx += 40) {
          ctx.strokeRect(x + bx, y + by, 39, 11);
        }
      }
      // Pressure plate indicator
      if (type === T.PRESSURE_PLATE) {
        const pp = pressurePlates.find(p => p.x === c && p.y === r);
        ctx.fillStyle = pp && pp.activated ? '#d4a44a' : '#8a7a6a';
        ctx.fillRect(x + 8, y, TILE - 16, 4);
        ctx.fillStyle = '#2a1a10';
        ctx.fillRect(x + 10, y + 1, TILE - 20, 1);
      }
      break;

    case T.LOOSE_FLOOR: {
      const lf = looseFloors.find(l => l.x === c && l.y === r);
      if (lf && lf.fallen) break;
      const off = lf ? lf.offset : 0;
      ctx.fillStyle = C.floorTop;
      ctx.fillRect(x, y + off, TILE, 4);
      ctx.fillStyle = C.loose;
      ctx.fillRect(x, y + 4 + off, TILE, TILE - 4);
      // Crack lines
      ctx.strokeStyle = '#1a0a00';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + 12, y + off); ctx.lineTo(x + 20, y + 6 + off);
      ctx.moveTo(x + 36, y + off); ctx.lineTo(x + 30, y + 8 + off);
      ctx.stroke();
      if (lf && lf.falling) {
        spawnParticles(x + Math.random() * TILE, y + off, 1, '#5a4a3a');
      }
      break;
    }

    case T.SPIKES:
      ctx.fillStyle = C.floorTop;
      ctx.fillRect(x, y, TILE, 4);
      ctx.fillStyle = C.floor;
      ctx.fillRect(x, y + 4, TILE, TILE - 4);
      // Draw spikes
      for (let i = 0; i < 4; i++) {
        const sx = x + 6 + i * 10;
        ctx.fillStyle = C.spike;
        ctx.beginPath();
        ctx.moveTo(sx, y);
        ctx.lineTo(sx + 5, y);
        ctx.lineTo(sx + 2.5, y - 14);
        ctx.closePath();
        ctx.fill();
        ctx.fillStyle = C.spikeDark;
        ctx.beginPath();
        ctx.moveTo(sx + 2.5, y);
        ctx.lineTo(sx + 5, y);
        ctx.lineTo(sx + 2.5, y - 14);
        ctx.closePath();
        ctx.fill();
      }
      break;

    case T.CHOMPER: {
      const ch = chompers.find(c2 => c2.x === c && c2.y === r);
      ctx.fillStyle = C.floorTop;
      ctx.fillRect(x, y, TILE, 4);
      ctx.fillStyle = C.floor;
      ctx.fillRect(x, y + 4, TILE, TILE - 4);
      // Chomper jaws
      const jawOpen = ch && ch.open ? 16 : 2;
      ctx.fillStyle = '#666';
      // Top jaw
      for (let i = 0; i < 3; i++) {
        const jx = x + 8 + i * 12;
        ctx.beginPath();
        ctx.moveTo(jx, y - jawOpen);
        ctx.lineTo(jx + 10, y - jawOpen);
        ctx.lineTo(jx + 5, y);
        ctx.closePath();
        ctx.fill();
      }
      // Bottom jaw
      if (!ch || !ch.open) {
        ctx.fillStyle = '#555';
        for (let i = 0; i < 3; i++) {
          const jx = x + 8 + i * 12;
          ctx.beginPath();
          ctx.moveTo(jx, y);
          ctx.lineTo(jx + 10, y);
          ctx.lineTo(jx + 5, y - 8);
          ctx.closePath();
          ctx.fill();
        }
      }
      break;
    }

    case T.GATE_CLOSED:
      ctx.fillStyle = C.gate;
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(x + 4 + i * 12, y, 4, TILE);
      }
      ctx.fillStyle = C.gateBar;
      ctx.fillRect(x, y + 12, TILE, 3);
      ctx.fillRect(x, y + 32, TILE, 3);
      break;

    case T.GATE_OPEN:
      ctx.fillStyle = C.gate;
      ctx.globalAlpha = 0.3;
      ctx.fillRect(x, y, TILE, 6);
      ctx.globalAlpha = 1;
      break;

    case T.TORCH:
      // Floor base
      ctx.fillStyle = C.floorTop;
      ctx.fillRect(x, y, TILE, 4);
      ctx.fillStyle = C.floor;
      ctx.fillRect(x, y + 4, TILE, TILE - 4);
      // Torch bracket
      ctx.fillStyle = '#6a5a4a';
      ctx.fillRect(x + 20, y - 24, 4, 20);
      ctx.fillRect(x + 16, y - 28, 12, 6);
      // Flame
      const flameH = 10 + torchFlicker * 4;
      const grad = ctx.createRadialGradient(x + 22, y - 34, 2, x + 22, y - 34, 12 + torchFlicker * 3);
      grad.addColorStop(0, 'rgba(255,200,80,0.9)');
      grad.addColorStop(0.4, 'rgba(255,120,20,0.6)');
      grad.addColorStop(1, 'rgba(255,80,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(x + 22, y - 34, 6 + torchFlicker * 2, flameH, 0, 0, Math.PI * 2);
      ctx.fill();
      // Glow
      const glow = ctx.createRadialGradient(x + 22, y - 30, 0, x + 22, y - 30, 80);
      glow.addColorStop(0, 'rgba(255,153,51,0.07)');
      glow.addColorStop(1, 'rgba(255,153,51,0)');
      ctx.fillStyle = glow;
      ctx.fillRect(x - 40, y - 80, 120, 120);
      break;

    case T.POTION: {
      const pot = potions.find(p => p.x === c && p.y === r);
      if (pot && pot.collected) break;
      // Potion bottle
      const bob = Math.sin(frameCount * 0.06) * 2;
      ctx.fillStyle = '#662222';
      ctx.fillRect(x + 18, y + 24 + bob, 12, 16);
      ctx.fillStyle = C.potion;
      ctx.fillRect(x + 20, y + 26 + bob, 8, 12);
      ctx.fillStyle = '#883333';
      ctx.fillRect(x + 21, y + 22 + bob, 6, 4);
      // Glow
      const pGlow = ctx.createRadialGradient(x + 24, y + 32, 0, x + 24, y + 32, 24);
      pGlow.addColorStop(0, C.potionGlow);
      pGlow.addColorStop(1, 'rgba(204,51,51,0)');
      ctx.fillStyle = pGlow;
      ctx.beginPath();
      ctx.arc(x + 24, y + 32, 24, 0, Math.PI * 2);
      ctx.fill();
      break;
    }

    case T.EXIT:
      // Doorway
      ctx.fillStyle = '#1a1208';
      ctx.fillRect(x + 8, y - 8, TILE - 16, TILE + 8);
      ctx.fillStyle = C.exit;
      ctx.fillRect(x + 6, y - 10, TILE - 12, 4);
      ctx.fillRect(x + 6, y - 10, 3, TILE + 10);
      ctx.fillRect(x + TILE - 9, y - 10, 3, TILE + 10);
      // Glow
      const eGlow = ctx.createRadialGradient(x + TILE/2, y + TILE/2, 0, x + TILE/2, y + TILE/2, 50);
      eGlow.addColorStop(0, 'rgba(212,164,74,0.15)');
      eGlow.addColorStop(1, 'rgba(212,164,74,0)');
      ctx.fillStyle = eGlow;
      ctx.beginPath();
      ctx.arc(x + TILE/2, y + TILE/2, 50, 0, Math.PI * 2);
      ctx.fill();
      // Shimmer
      const shimmer = Math.sin(frameCount * 0.08) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(212,164,74,${shimmer * 0.1})`;
      ctx.fillRect(x + 10, y - 6, TILE - 20, TILE + 4);
      break;
  }
}

function drawEntity(ent, color, outlineColor, isEnemy) {
  if (ent.state === 'dead' && isEnemy) {
    // Dead enemy on ground
    ctx.fillStyle = outlineColor;
    ctx.globalAlpha = 0.6;
    ctx.fillRect(ent.x - 16, ent.y - 6, 32, 6);
    ctx.globalAlpha = 1;
    return;
  }

  const x = ent.x;
  const y = ent.y;
  const f = ent.facing;
  const flash = ent.hurtTimer > 0 && ent.hurtTimer % 4 < 2;

  if (flash) { color = '#ffffff'; outlineColor = '#ff6666'; }

  // Body
  ctx.fillStyle = outlineColor;
  ctx.fillRect(x - 6, y - 38, 12, 34);

  // Tunic / body
  ctx.fillStyle = color;
  if (isEnemy) {
    ctx.fillStyle = '#aa3333';
  }
  ctx.fillRect(x - 5, y - 36, 10, 18);

  // Head
  ctx.fillStyle = isEnemy ? '#cc8866' : '#ddbb99';
  ctx.fillRect(x - 4, y - 42, 8, 8);

  // Hair/turban
  ctx.fillStyle = isEnemy ? '#442222' : '#ffffff';
  ctx.fillRect(x - 5, y - 44, 10, 4);

  // Pants
  ctx.fillStyle = isEnemy ? '#663333' : '#bbaa88';
  ctx.fillRect(x - 5, y - 18, 10, 14);

  // Legs animation
  const legPhase = ent.state === 'run' ? Math.sin(ent.animFrame * 0.8) * 4 : 0;
  ctx.fillStyle = isEnemy ? '#553322' : '#aa9977';
  ctx.fillRect(x - 4 + legPhase, y - 6, 3, 6);
  ctx.fillRect(x + 1 - legPhase, y - 6, 3, 6);

  // Arms
  ctx.fillStyle = isEnemy ? '#cc8866' : '#ddbb99';
  if (ent.state === 'attack' && ent.attackTimer > 4) {
    // Extended attack arm
    ctx.fillRect(x + f * 8, y - 34, f * 18, 3);
    // Sword
    if (ent.hasSword || (!isEnemy && player.hasSword)) {
      ctx.fillStyle = '#cccccc';
      ctx.fillRect(x + f * 24, y - 36, f * 14, 2);
      ctx.fillStyle = '#ffeecc';
      ctx.fillRect(x + f * 36, y - 37, f * 4, 4);
    }
  } else {
    // Normal arm
    ctx.fillRect(x + f * 5, y - 34, 3, 10);
    // Sword at rest
    if ((isEnemy && ent.hasSword) || (!isEnemy && player.hasSword)) {
      ctx.fillStyle = '#aaaaaa';
      ctx.fillRect(x + f * 7, y - 24, 2, 14);
    }
  }

  // Block stance indicator
  if (isEnemy && ent.blockTimer > 0) {
    ctx.fillStyle = '#cccccc';
    ctx.fillRect(x - f * 2, y - 38, 2, 20);
  }

  // Crouch
  if (ent.state === 'crouch') {
    ctx.fillStyle = outlineColor;
    ctx.fillRect(x - 6, y - 24, 12, 20);
    ctx.fillStyle = isEnemy ? '#cc8866' : '#ddbb99';
    ctx.fillRect(x - 4, y - 28, 8, 6);
  }
}

function drawBackground() {
  // Background with dungeon atmosphere
  ctx.fillStyle = C.bg;
  ctx.fillRect(0, 0, W, H);

  // Subtle stone texture via noise
  ctx.fillStyle = 'rgba(255,255,255,0.008)';
  for (let i = 0; i < 80; i++) {
    const nx = ((i * 97) % W);
    const ny = ((i * 53) % H);
    ctx.fillRect(nx, ny, 2, 2);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.fillStyle = p.color;
    ctx.globalAlpha = p.life / p.maxLife;
    ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
  }
  ctx.globalAlpha = 1;
}

// ---- HUD ----
function updateHUD() {
  const ph = document.getElementById('playerHealth');
  ph.innerHTML = '';
  for (let i = 0; i < player.maxHealth; i++) {
    const pip = document.createElement('div');
    pip.className = 'health-pip ' + (i < player.health ? 'full' : 'empty');
    ph.appendChild(pip);
  }

  const eh = document.getElementById('enemyHealth');
  eh.innerHTML = '';
  const activeEnemy = enemies.find(e => !e.dead && Math.abs(e.x - player.x) < 200);
  if (activeEnemy) {
    for (let i = 0; i < activeEnemy.health; i++) {
      const pip = document.createElement('div');
      pip.className = 'health-pip full';
      pip.style.borderColor = '#662222';
      pip.style.background = '#cc3333';
      eh.appendChild(pip);
    }
  }

  document.getElementById('levelDisplay').textContent = `LEVEL ${currentLevel + 1}`;

  const mins = Math.floor(gameTime / 60);
  const secs = gameTime % 60;
  document.getElementById('timerDisplay').textContent =
    `${String(mins).padStart(2,'0')}:${String(secs).padStart(2,'0')}`;
}

// ---- MAIN LOOP ----
function update() {
  if (gameState !== 'playing') return;

  frameCount++;
  if (frameCount % 60 === 0 && gameTime > 0) {
    gameTime--;
    if (gameTime <= 0) {
      killPlayer();
    }
  }

  updatePlayer();
  updateEnemies();
  updateEnvironment();
  updateParticles();

  if (screenShake > 0) screenShake--;
}

function draw() {
  ctx.save();

  if (screenShake > 0 && gameState === 'playing') {
    ctx.translate(
      (Math.random() - 0.5) * screenShake,
      (Math.random() - 0.5) * screenShake
    );
  }

  drawBackground();

  // Draw tiles
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (map[r][c] !== T.EMPTY) {
        drawTile(c, r, map[r][c]);
      }
    }
  }

  // Draw entities
  if (player.state !== 'dead' || frameCount % 8 < 4) {
    drawEntity(player, C.player, C.playerOutline, false);
  }

  for (const e of enemies) {
    drawEntity(e, C.enemy, C.enemyOutline, true);
  }

  drawParticles();

  // Vignette
  const vignette = ctx.createRadialGradient(W/2, H/2, H * 0.4, W/2, H/2, H * 0.9);
  vignette.addColorStop(0, 'rgba(0,0,0,0)');
  vignette.addColorStop(1, 'rgba(0,0,0,0.5)');
  ctx.fillStyle = vignette;
  ctx.fillRect(0, 0, W, H);

  // Scanline effect
  ctx.fillStyle = 'rgba(0,0,0,0.06)';
  for (let y = 0; y < H; y += 3) {
    ctx.fillRect(0, y, W, 1);
  }

  ctx.restore();
}

function gameLoop() {
  update();
  draw();

  // Clear keyDown
  for (const k in keyDown) keyDown[k] = false;

  requestAnimationFrame(gameLoop);
}

// ---- MENU / STATE HANDLING ----
window.addEventListener('keydown', e => {
  if (e.code === 'Enter') {
    if (gameState === 'menu') {
      gameState = 'playing';
      document.getElementById('overlay').classList.add('hidden');
      loadLevel(currentLevel);
    } else if (gameState === 'dead') {
      document.getElementById('deathOverlay').classList.remove('show');
      gameState = 'playing';
      loadLevel(currentLevel);
    } else if (gameState === 'win') {
      document.getElementById('winOverlay').classList.remove('show');
      currentLevel++;
      if (currentLevel >= levels.length) {
        currentLevel = 0;
      }
      gameState = 'playing';
      loadLevel(currentLevel);
    }
  }
});

// Start
loadLevel(0);
gameLoop();
</script>
</body>
</html>
